** DONE Svelte                                                   :ext:ponpon:
<2024-10-08 Tue>

- [X] Svelte Material UIを独自のボタンに置き換える
  - ページスクリプトのCSSが変わってしまうため
  - [X] button
  - [X] toast
  - [X] modal
- [X] vite-pluginで指定するviteのバージョンが低すぎて、viteが古い
  - 最新が入っていた
  - resolusions->overridesにして--forceを不要にした
  - o @crxjs/vite-plugin@beta
- [X] svelte-i18n


** DOING ブラウザー拡張 Banban Ponpon                            :ponpon:ext:
<2024-10-08 Tue>

- [X] Productionと一緒に使うと ppa-hiranoとrequest.landが混じってpostMessage()でエラー
  - ボタンをつけてみたが、各ページのCSとBSの定数も書き換えられない
  - run prod新設
- [ ] エラーが出たタブのクローズ

** DOING Ponponでのユーザー認証                       :user:login:ponpon:ext:
<2024-10-03 Thu>

- [X] ログインのtimeout
- [X] proxyがCSにpostMessageをする際のセキュリティ確保
- verifyServerResponse()はverificationResponseにopenerIDを追加して、サーバーから受け取ったauthenticateの返り値をpostMessageする
  - これはCSに届かなかった postMsg(msg, 'chrome-extension://jdpcgdnhmbamgljldgbibpnmoaognnln')
  - とりあえず'*'に送るようにしてCSに届いているが、悪意の第三者が設置したサイトから開かれたlogin-proxy-viewであったらATが盗まれるため、window.openerがCSか確認する

     window.opener?.postMessage(verificationResponse, '*');

  - window.openerがCSであるか？
    - x 変数がアクセスできない
  - x proxyがyamaを送り、yamaを受け取ったCSがkawaを送り、受け取ったproxyがevent.originがCSであるか確認
    - x event.originに"null"が入っていた
      - window.opener.thenにエラーが入っていた
        - Exception: SecurityError: Blocked a frame with origin "https://ppa-hirano.peace-and-passion.com:50000" from accessing a cross-origin frame. at LoginProxyView.openerMessageHandler
  - CSがサーバーからnonceをもらい、proxyに渡し、proxyがサーバーのsigninに渡すことで検証
    - x 大掛かり
  - refererでlogin-proxy-viewを開けないようにする？
  - window.opener以外には届かないため、'*'でセキュリティ上の問題はない

- [X] page scriptからcontent scriptにpostMessage(msg, chrome-extension://xx)できない


- [X] 関数の整備 ATの置き場所
- [X] タブにリクエストランドがあり、ログインしていないときにATがnullになる
- [X] login-proxy-viewでデフォルトのHHH//h-comと、select passkeyを出す
  - [X] cookie.land_idがない場合は大きいselectボタン
  - [X] cookie.land_idがある場合は小さいselectボタン
- [X] land_idも返す
- [ ] 複数のATとユーザーの関係の整理
- [ ] ログインして得たATを保持
- [ ] DOMのATを消す

** DONE Page ScriptからContent ScriptにATを渡す
<2024-10-11 Fri>

- x page scriptからcontent scriptにpostMessage(msg, chrome-extension://xx)できない
        window.addEventListener('message', (event: MessageEvent) => {
- '*'も届かない
  - コンテンツスクリプトやウェブコンテキストスクリプトは targetOrigin を拡張機能 (バックグラウンドス
    クリプトやコンテンツスクリプト) と直接通信するために指定することはできません。ウェブやコンテンツ
    のスクリプトは、 window.postMessage を targetOrigin を "*" にして使用することで、すべてのリスナー
    にブロードキャストすることができますが、これは拡張機能がそのようなメッセージのオリジンを特定する
    ことができないこと、他のリスナー (制御するべきでないものも含む) が待ち受けしている可能性があるた
    め推奨されません。
- x PSがDOMに挿入し、CSがMutationをdetectする
  - できたが面倒
- [[https://developer.apple.com/documentation/safariservices/messaging-between-a-webpage-and-your-safari-web-extension][SafariとChromeではPSからCSにsendMessage()できる]]  [[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/externally_connectable][MDN]]によればFFでは使えない

- document.dispatchEvent <2024-10-11 Fri>  どのブラウザーでも使える
  - 他のoriginのスクリプトに傍受されないように、CSが乱数を生成してPSに渡し、PSは乱数をevent名にして値を返す

    dispathEvent(new CustomEvent(乱数, { detail: userInfo }))

  - 実装
            // handler for ask by Ponpon extension for UserInfo including access token
            if (event.origin == conf.originUri && event.data?.type === 'getAccessTokenFromPageScript') {
                const userInfoInquiry: UserInfoInquiry = event.data;
                let userInfo: UserInfo|string = 'null';
                if (this.hasValidAccessToken()) {
                    userInfo = {
                        at:              this.userService.accessToken,
                        atExp:           this.userService.accessTokenExpiration,
                        land_id:         localStorage.land_id,
                        primaryColor:    App.app.primaryColor,
                        accentColor:     App.app.accentColor,
                        appBarTextColor: App.app.appBarTextColor
                    }
                }
                this.log.info('sending answerAccessTokenFromPageScript');
                document.dispatchEvent(new CustomEvent(userInfoInquiry.returnEvent, { detail: userInfo }));
            }
        });

** TODO Svelet LSP
** TODO primaryColorで色を変える
** DOING ログイン、開いているボードをどう扱うか仕様
<2024-10-11 Fri>

- 要件
  - ユーザーは、開いているボードにカードが入ると思っている
  - ユーザーは、ポンポンの設定をしたくない。ボードを開くたびにポンポンの設定をしたいとは思わない
  - Safari PWAではPonponは動かない。サーバーを介する必要がある

- 案
  - スタートボタンを押したとき
    - hm-appがある
      - ATを得てputCardで使う
      - バンバンボードを開いている -> CSを介してボードのIDとタイトルを表示
        - カードの追加ではボードに直接入れる
      - バンバンボードを開いていない
        - サーバーからgetLastCardboardID APIで、最後に開いたボードのIDをタイトルを得て表示
        - カードの追加ではputCardExt(AT, CardboardID)
      - hm-appはログインをしたとき、ボードを変更したときにCSを介してMainに通知
    - ない (SafariのPWAが開いているかはわからない)
      - proxyでログインする
      - サーバーからgetLastCardboardID APIで、最後に開いたボードのIDをタイトルを得て表示
      - カードの追加ではputCardExt(AT, CardboardID)
  - Originが同じ[[https://www.netguru.com/blog/how-to-share-session-cookie-or-state-between-pwa-in-standalone-mode-and-safari-on-ios][PWAとSafariのhm-appでデータを共有]]
    - x Safariでhm-appが動いている必要がある
  -
