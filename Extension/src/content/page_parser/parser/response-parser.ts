//import {DOMParser} from "https://esm.sh/linkedom";
// import {JSDOM} from "https://esm.sh/jsdom";
// import {JSDOM} from "jsdom";
import {select} from "npm:xpath";
import {ParsePageResult, ShopPrice, Currency} from '../types.ts';
import {parseLdjson} from './ld-parser.ts';
import {findLdjson, findMicrodata, findDescription, findOgImage, findOgPriceCode, findOgPriceValue, findImagesFromMainImage, findSiteName} from "./structured-data-parser.js";
import {isHTMLString, replaceURLToAbsolute, addTargetBlankToHref, decodeHtmlEntities} from "../utils/utils.ts";

/** DOMParser for parse response html */
const domParser: DOMParser = new DOMParser();


/**
 * Parse page with itemprop, ldjson, og.
 *
 * @param page - page after fetch.
 * @param url - target url.
 * @returns ParsePageResult promise with parsed data.
 *
 * @tests deno test -A  src/test/parser/response-parser_test.ts
 */

/**
export async function parseResponse(response: Response, url: string, baseParsePageResult?: ParsePageResult, controller?: ReadableByteStreamController, override?: boolean): Promise<ParsePageResult> {
    const parsePageResult: ParsePageResult = baseParsePageResult || new ParsePageResult();

    const txt: string = await response.text();
    console.debug("Benchmark: start parseFromString " + (new Date()).toISOString())
    // const dom: any = new JSDOM(txt);
    // const document: any = dom.window.document;
    const document: any = domParser.parseFromString(txt || "", "text/html");
    console.debug("Benchmark: end parseFromString " + (new Date()).toISOString())

    await responseParseMicrodata(document, url, parsePageResult)
    if (!parsePageResult.isCompleted()) await responseParseLdjson(document, url, parsePageResult);
    if (!parsePageResult.isCompleted()) await responseParseOg(document, url, parsePageResult);

    responseParseDescriptionHTML(document, parsePageResult);
    responseFindImagesFromMainImage(document, url, parsePageResult);

    // update site name
    responseParseSiteName(document, url, parsePageResult);
    return parsePageResult;

}
*/

export async function parseResponse(
  document: Document,  // 必ず存在する `document` オブジェクト
  url: string,  // ページのURL
  baseParsePageResult?: ParsePageResult  // 途中までの解析結果（オプション）
): Promise<ParsePageResult> {

  const parsePageResult: ParsePageResult = baseParsePageResult || new ParsePageResult();

  // 1. document オブジェクトからデータを取得・解析
  console.debug("Benchmark: start parsing", new Date().toISOString());

  // Microdata、JSON-LD、Open Graph などを解析
  await responseParseMicrodata(document, url, parsePageResult);
  if (!parsePageResult.isCompleted()) await responseParseLdjson(document, url, parsePageResult);
  if (!parsePageResult.isCompleted()) await responseParseOg(document, url, parsePageResult);

  responseParseDescriptionHTML(document, parsePageResult);
  responseFindImagesFromMainImage(document, url, parsePageResult);
  responseParseSiteName(document, url, parsePageResult);

  console.debug("Benchmark: end parsing", new Date().toISOString());

  // 2. 解析結果を返す
  return parsePageResult;
}




/**
 * reference for findMicrodata()
 *
 * @param document - Document generated by DOMParser
 * @param url - web page url
 * @param parsePageResult - result
 * @return void
 *
 * @tests deno test -A  src/test/parser/response-parser_test.ts --filter 'parseResponse-microdata'
 */
export async function responseParseMicrodata(document: any, url: string, parsePageResult: ParsePageResult): Promise<void> {
    const ldjsonStr: string = findMicrodata(document);
    parseLdjson(ldjsonStr, url, parsePageResult);
}


/**
 * reference for findLdjson()
 * @param document - Document generated by DOMParser
 * @param url - web page url
 * @param parsePageResult - result
 * @return void
 *
 * @tests deno test -A  src/test/parser/response-parser_test.ts --filter 'parseResponse-ldjson'
 */
export async function responseParseLdjson(document: any, url: string, parsePageResult: ParsePageResult): Promise<void> {
    const ldjsonStrs: string[] = findLdjson(document);
    parseLdjson(ldjsonStrs, url, parsePageResult);
}


/**
 * reference for findOgPrice
 * @param document - Document generated by DOMParser
 * @param url - web page url
 * @param parsePageResult - result
 * @return void
 *
 * @tests deno test -A  src/test/parser/response-parser_test.ts --filter 'parseResponse-og'
 */
export async function responseParseOg(document: any, url: string, parsePageResult: ParsePageResult): Promise<void> {
    if (!parsePageResult.title) parsePageResult.title = decodeHtmlEntities(document.title);
    if (!parsePageResult.description) {
        const description: string|null = findDescription(document);
        if (description) parsePageResult.description = decodeHtmlEntities(addTargetBlankToHref(replaceURLToAbsolute(url, description)));
    }
    if (!parsePageResult.imageURLs || parsePageResult.imageURLs.length == 0) {
        const ogImage: string|null = findOgImage(document);
        if (ogImage) parsePageResult.addImageURL(ogImage, new URL(url).hostname);
    }

    // price
    if (!parsePageResult.shopPrices || parsePageResult.shopPrices.length == 0) {
        // <meta property="og:product:amount" content="1284">
        // <meta property="og:product:currency" content="USD">
        const priceValue: string|null = findOgPriceValue(document);
        const priceCode: string|null = findOgPriceCode(document);
        if (priceValue && priceCode) {
            parsePageResult.shopPrices = [
                new ShopPrice("", url, new Currency(priceCode, priceValue))
            ];
        }
    }

    return;
}


/**
 * reference for findLdjson()
 * @param document - Document generated by DOMParser
 * @param url - web page url
 * @param parsePageResult - result
 * @return void
 *
 * @tests deno test -A  src/test/parser/response-parser_test.ts --filter 'parseResponse-DescriptionHTML'
 */
export async function responseFindImagesFromMainImage(document: any, url: string, parsePageResult: ParsePageResult): Promise<void> {
    if (!parsePageResult.imageURLs || parsePageResult.imageURLs.length == 0) return;
    const imageURLs: string[] = findImagesFromMainImage(document, parsePageResult.imageURLs[0]);
    if (imageURLs) parsePageResult.addImageURL(imageURLs, new URL(url).hostname)
}


/**
 * reference for findSiteName()
 * @param document - Document generated by DOMParser
 * @param url - web page url
 * @param parsePageResult - result
 * @return void
 *
 * @tests deno test -A  src/test/parse-real-pages_test.ts --filter getParsePageResult
 */
export async function responseParseSiteName(document: any, url: string, parsePageResult: ParsePageResult): Promise<void> {
    const siteName: string|null|undefined = parsePageResult.siteName || findSiteName(document);
    if (siteName) {
        parsePageResult.siteName = siteName;
        for (let shopPrice of parsePageResult?.shopPrices || []) {
            if (!shopPrice.name) shopPrice.name = siteName;
        }
    }
}



/**
 * XXX TODO Impliment me: https://github.com/denoland/deno/issues/18315
 * After fix me, Promise.all() -> Promise.race() in puppeteer-handler and uncomment controller.close() in types.ts
 */
function responseParseDescriptionHTML(document: any, parsePageResult: ParsePageResult): void {
    return;

    // console.log("\n\n\n response parsedescriptionhtml")
    // if (!parsePageResult.description || isHTMLString(parsePageResult.description)) return;
    // const queryStr: string|undefined = parsePageResult.makeXPathQueryForDescription();
    // if (queryStr) {
    //     console.log("\n\n\n response parsedescriptionhtml")
    //     const elems: any = select(queryStr, document);
    // }
}
